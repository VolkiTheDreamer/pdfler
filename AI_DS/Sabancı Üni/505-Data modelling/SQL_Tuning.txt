-- SYS: Grant dba to sh user

grant dba to sh;
grant dba to cm;
grant dba to hr;

-- Timing On    

set timing on

-- Flush Memory 

alter system flush shared_pool;
alter system flush buffer_cache;


-- 0 - OPTIMIZER ?

ALTER SESSION SET TRACEFILE_IDENTIFIER = "MY_TEST_SESSION";
ALTER SESSION SET EVENTS '10053 TRACE NAME CONTEXT FOREVER, LEVEL 1';
ALTER SESSION SET statistics_level='ALL';

SELECT  last_name, job_title, department_name, start_date
FROM    hr.job_history h
INNER JOIN hr.jobs j on h.job_id=j.job_id
INNER JOIN hr.departments d on h.department_id=d.department_id
INNER JOIN hr.employees e on h.employee_id=e.employee_id
WHERE to_char(h.start_date,'YYYY') BETWEEN 2001 AND 2005
ORDER BY h.start_date;

--cd /u01/app/oracle/diag/rdbms/orcl/orcl/trace




--1 - Correlated Subquery Usage - SH

-- Correlation SQL -------------------------------------------------------------
-- Compare costs

SELECT COUNT(*)
FROM   products p
WHERE  prod_list_price < 1.15 * (SELECT avg(unit_cost)
                                 FROM costs c
                                 WHERE c.prod_id = p.prod_id);

SELECT /*+ NO_QUERY_TRANSFORMATION */ COUNT(*)
FROM   products p
WHERE  prod_list_price < 1.15 * (SELECT avg(unit_cost)
                                 FROM costs c
                                 WHERE c.prod_id = p.prod_id);

-- Flush Memory 

alter system flush shared_pool;
alter system flush buffer_cache;

-- NonCorrelation SQL ----------------------------------------------------------

SELECT COUNT(*)
FROM   products p, (SELECT prod_id, AVG(unit_cost) ac FROM costs GROUP BY prod_id) c
WHERE  p.prod_id = c.prod_id AND
       p.prod_list_price < 1.15 * c.ac;
       
       
-- Example 2 (HR)
SELECT department_id, last_name, salary 
FROM employees e1 
WHERE salary > (SELECT AVG(salary) 
                FROM employees e2
                WHERE e1.department_id = e2.department_id
                GROUP BY e2.department_id) 
ORDER BY department_id;

SELECT employee_id, last_name, salary
FROM employees e1
          , (SELECT avg(salary) avg_sal, department_id
             FROM employees
             GROUP BY department_id) a
WHERE e1.salary > a.avg_sal
AND e1.department_id = a.department_id;
       

set timing on
alter system flush shared_pool;
alter system flush buffer_cache;


-- 2- JOIN Condition - CM

-- Function on join column -----------------------------------------------------
-- Compare costs

SELECT  count(*)
FROM   job_history jh, employees e
WHERE  substr(to_char(e.employee_id),1) = substr(to_char(jh.employee_id),1);

-- Flush
alter system flush shared_pool;
alter system flush buffer_cache;

-- Better Join

SELECT count(*)
FROM   job_history jh, employees e
WHERE  e.employee_id = jh.employee_id;

-- Flush
alter system flush shared_pool;
alter system flush buffer_cache;



-- 3 - Implicit type conversion - CM

-- Data type mismatch 
-- Compare costs & plans

SELECT * FROM orders WHERE order_id_char = 1205;

-- Flush
alter system flush shared_pool;
alter system flush buffer_cache;

-- Better predicate (type conversion)

SELECT * FROM orders WHERE order_id_char = '1205';

-- Flush
alter system flush shared_pool;
alter system flush buffer_cache;


-- 4 - UNION & UNION ALL  - CM

-- Sorting required or not?

select count(*)
from (select name from old union select name from new);

-- Flush
alter system flush shared_pool;
alter system flush buffer_cache;

-- Better UNION

select count(*)
from (select name from old union all select name from new);



-- 5 - Setup Multiple - CM

-- Multiple SQL-1
-- Minimize the number of table scan 

set echo on
set timing on

SELECT COUNT (*)
FROM myemp
WHERE salary < 2000;

SELECT COUNT (*)
FROM myemp
WHERE salary BETWEEN 2000 AND 4000;

SELECT COUNT (*)
FROM myemp
WHERE salary>4000;


-- Multiple SQL-2

set echo on
set timing on

SELECT COUNT (CASE WHEN salary < 2000 
                   THEN 1 ELSE null END) count1, 
       COUNT (CASE WHEN salary BETWEEN 2001 AND 4000 
                   THEN 1 ELSE null END) count2, 
       COUNT (CASE WHEN salary > 4000 
                   THEN 1 ELSE null END) count3 
FROM myemp;



-- 6 - Using LIKE '%STRING' - SH

-- Index used or not?

select cust_first_name, cust_last_name
  from customers
 where cust_last_name like '%ing';

select cust_first_name, cust_last_name
  from customers
 where cust_last_name like 'ing%';

create index cust_last_name_rix on customers(REVERSE(cust_last_name)) nologging compute statistics;

select cust_first_name, cust_last_name
  from customers
 where reverse(cust_last_name) like 'gni%';
 
drop index cust_last_name_rix;



-- 7 - TEMP Table Usage - SH

select sum(amount_sold)
  from sales s, times t, customers c 
 where s.time_id  = t.time_id
   and s.cust_id  = c.cust_id
   and t.day_name = 'Friday' 
   and country_id = 52772;
 
select sum(amount_sold)
  from sales s, times t, products p 
 where s.time_id  = t.time_id
   and s.prod_id  = p.prod_id
   and t.day_name = 'Friday' 
   and prod_category = 'Electronics';
   
select sum(amount_sold)
  from sales s, times t, promotions p 
 where s.time_id  = t.time_id
   and s.promo_id = p.promo_id 
   and t.day_name = 'Friday' 
   and promo_category= 'TV';


create GLOBAL TEMPORARY TABLE sales_friday (prod_id, cust_id, promo_id, amount_sold) on commit preserve rows
    as 
select prod_id, cust_id, promo_id, amount_sold 
  from sales s, times t
 where s.time_id = t.time_id
   and t.day_name = 'Friday';
   
select sum(amount_sold)
  from sales_friday s, customers c
 where s.cust_id  = c.cust_id
   and country_id = 52772;

select sum(amount_sold)
  from sales_friday s, products p 
 where s.prod_id  = p.prod_id
   and prod_category = 'Electronics';
   
select sum(amount_sold)
  from sales_friday s, promotions p 
 where s.promo_id = p.promo_id 
   and promo_category= 'TV';


truncate table sales_friday;
drop table sales_friday;


-- 8 - USING BIND VARIABLES (HARD PARSE) - SH

select count(*) from customers where cust_city_id=51656;
select count(*) from customers where cust_city_id=51181;
select count(*) from customers where cust_city_id=51793;

select sql_text, executions
from v$sql
where sql_text like '%cust_city_id=%';

select count(*) from customers where cust_city_id=:city_id;


-- 9 - DB Connection - TERMINAL

-- cd /home/oracle/labs/solutions/Common_Mistakes
-- ./bad_connect.sh
-- ./better_connect.sh




-- 10 - NULL USAGE (INDEX) - SH

drop index customers_marital_bix;
drop index cust_marital_status_idx;
create index cust_marital_status_idx on customers(cust_marital_status);

select count(*) from customers where cust_marital_status is null;
select /*+ index(c cust_marital_status_idx) */ count(*) from customers c where cust_marital_status is null;
select count(*) from customers where cust_marital_status is not null;

drop index cust_marital_status_idx;



-- 11 - Having always evaluated after the group by  - SH

SELECT   ui.table_name
,        decode(ui.index_type
               ,'NORMAL', ui.uniqueness
               ,ui.index_type) AS index_type
,        ui.index_name
FROM     user_indexes  ui
WHERE    ui.table_name = 'CUSTOMERS'
ORDER BY ui.table_name
,        ui.uniqueness desc;

CREATE INDEX cust_city_idx
ON customers(cust_city)
NOLOGGING COMPUTE STATISTICS;

select cust_city, avg(cust_credit_limit)
from customers
group by cust_city
having cust_city='Paris';

select cust_city, avg(cust_credit_limit)
from customers
where cust_city='Paris'
group by cust_city; 

drop index cust_city_idx;


-------------------------------INDEX-------------------------------------------

--setup: - SH

drop table mysales purge;

create table mysales as select * from sh.sales;

insert into mysales select * from mysales;
commit;

insert into mysales select * from mysales;
commit;

insert into mysales select * from mysales;
commit;

insert into mysales select * from mysales;
commit;

insert into mysales select * from mysales;
commit;

insert into mysales values (0,0,sysdate,0,0,0,0);
commit;

--1 with/without index --------------------------------------------------------

SELECT   ui.table_name
,        decode(ui.index_type
               ,'NORMAL', ui.uniqueness
               ,ui.index_type) AS index_type
,        ui.index_name
FROM     user_indexes  ui
WHERE    ui.table_name = 'MYSALES'
ORDER BY ui.table_name
,        ui.uniqueness desc;

-- without index 

drop index mysales_prodid_idx;

select * from mysales where prod_id=0;

-- with index 

-- create index
create index mysales_prodid_idx on mysales(prod_id) nologging;

-- gather statistics
exec dbms_stats.gather_schema_stats('SH');

select * from mysales where prod_id=0;

select distinct prod_id from mysales; where prod_id=0;



--2 compare single column Index Access -----------------------------------------

-- cleanup
drop table mysales purge;

-- sqlplus sh/sh @drop_customers_indexes.sql



SELECT /*+ FULL(c) */ c.*                  
FROM   customers c
WHERE  cust_gender   = 'M'
AND    cust_postal_code = 40804
AND   cust_credit_limit = 10000;

-- create index

CREATE INDEX cust_cust_gender_idx
ON customers(cust_gender)
NOLOGGING COMPUTE STATISTICS;

CREATE INDEX cust_cust_postal_code_idx
ON customers(cust_postal_code)
NOLOGGING COMPUTE STATISTICS;

CREATE INDEX cust_cust_credit_limit_idx
ON customers(cust_credit_limit)
NOLOGGING COMPUTE STATISTICS;

-- list indexes

SELECT   ui.table_name
,        decode(ui.index_type
               ,'NORMAL', ui.uniqueness
               ,ui.index_type) AS index_type
,        ui.index_name
FROM     user_indexes  ui
WHERE    ui.table_name = 'CUSTOMERS'
ORDER BY ui.table_name
,        ui.uniqueness desc;

-- start monitoring index

set echo on

ALTER INDEX CUSTOMERS_PK MONITORING USAGE;

ALTER INDEX CUST_CUST_POSTAL_CODE_IDX MONITORING USAGE;

ALTER INDEX CUST_CUST_GENDER_IDX MONITORING USAGE;

ALTER INDEX CUST_CUST_CREDIT_LIMIT_IDX MONITORING USAGE;

-- check monitoring

select * from v$object_usage;

-- Q1 Optimizer chooses to use only one index --> CUST_CUST_POSTAL_CODE_IDX

SELECT /*+ INDEX(c) */ c.*                  
FROM   customers c
WHERE  cust_gender   = 'M'
AND    cust_postal_code = 40804
AND   cust_credit_limit = 10000;

-- Q2 Optimizer uses multiple index but cost is higher

SELECT /*+ INDEX_COMBINE(c) */ c.*   
FROM   customers c      
WHERE  cust_gender   = 'M'
AND    cust_postal_code = 40804
AND   cust_credit_limit = 10000;



--3 Concatenated Index --------------------------------------------------------

-- Cleanup
-- sqlplus sh/oracle @/home/oracle/labs/solutions/Access_Paths/drop_customers_indexes.sql

-- Create index
set echo on

CREATE INDEX cust_gender_limit_code_idx
ON customers(cust_gender,cust_credit_limit,cust_postal_code)
NOLOGGING COMPUTE STATISTICS;

-- Autotrace Q1

-- Q1 again? --> Best plan

SELECT /*+ INDEX(c) */ c.*                  
FROM   customers c
WHERE  cust_gender   = 'M'
AND    cust_postal_code = 40804
AND   cust_credit_limit = 10000;

-- Q3 --> Postal_Code removed

SELECT /*+ INDEX(c) */ c.*   
FROM   customers c      
WHERE  cust_gender   = 'M'
AND   cust_credit_limit = 10000; --Selectivity?

-- Q4
SELECT /*+ INDEX(c) */ c.*                  
FROM   customers c
WHERE cust_gender = 'M'
AND   cust_postal_code = 40804;

-- Q5
SELECT /*+ INDEX(c) */ c.*                  
FROM   customers c
WHERE  cust_postal_code = 40804
 AND   cust_credit_limit = 10000;


--4 Index Only Access --------------------------------------------------------

-- Cleanup
-- @drop_customers_indexes.sql

-- Create concatenated index
set echo on

CREATE INDEX cust_last_first_name_idx
ON customers(cust_last_name,cust_first_name)
NOLOGGING COMPUTE STATISTICS;

-- Q6
SELECT c.cust_last_name          
,      c.cust_first_name
FROM   customers c;       


--5 Function Based Index -------------------------------------------------------

-- Cleanup
-- @/home/oracle/labs/solutions/Access_Paths/drop_customers_indexes.sql

-- Create index
set echo on

CREATE INDEX cust_cust_last_name_idx
ON customers(cust_last_name)
NOLOGGING COMPUTE STATISTICS;

-- Q7
SELECT cust_id, country_id 
FROM customers              
WHERE LOWER( cust_last_name) LIKE 'gentle';

-- Create function based index
set echo on

CREATE INDEX lower_cust_last_name_idx ON
customers(LOWER(cust_last_name));


--------------------------------------------------------------------------------

-- setup

drop table sh.cust purge;

create table sh.cust (
cust_id number primary key,
cust_first_name varchar(20),
cust_last_name varchar(40),
cust_credit_limit number,
cust_state_province varchar2(40)
);

insert into sh.cust
select cust_id, cust_first_name, cust_last_name, 
cust_credit_limit, cust_state_province
from sh.customers;

commit;

create index sh.cust_cust_state_province_idx
on sh.cust(cust_state_province)
nologging
compute statistics;

exec dbms_stats.gather_table_stats('SH','CUST',method_opt=>'for all indexed columns',cascade=>true);

desc sh.cust;

---------------------------------------

-- Autotrace which index used?
SELECT cust_first_name, cust_last_name, cust_credit_limit
FROM sh.cust
WHERE cust_state_province = 'NJ'
ORDER BY cust_last_name, cust_first_name;

-- Create composite index
drop index cust_fn_ln_idx;

create index sh.cust_fn_ln_idx
on sh.cust(cust_first_name,cust_last_name);

-- try autotrace. result?

-- try hint. result?
SELECT /*+ index (cust cust_fn_ln_idx)*/ cust_first_name, cust_last_name, cust_credit_limit
FROM sh.cust
WHERE cust_state_province = 'NJ'
ORDER BY cust_last_name, cust_first_name;

-- add NOT NULL constraint at least one column
alter table sh.cust modify(cust_last_name not null);

-- try autotrace. result?

-- Drop & Recreate composite index (change order)
drop index cust_fn_ln_idx;

create index sh.cust_fn_ln_idx
on sh.cust(cust_last_name,cust_first_name);

-- try autotrace. result?

--------------------------------------------------------------------------------

-- Access paths


--Nested Loop: is typically used when small subsets of tables are joined 
--or if there is an efficient way of accessing the inner table, for example with an index lookup.

--Hash Join: is usually preferred for (equi)joining large data sets. 
--The query optimizer takes the smaller of two data sources to build a hash table in memory. 
--It then scans the larger table and performs the same hashing on the join columns.

--Sort Merge Join: when join conditions are inequalities (i.e. not an equijoin). 
--It is commonly chosen if there is an index on one of the tables that eliminates a sort operation
--A sort-merge join proceeds in two steps:
--1. Sort join: both tables are sorted on the join key
--2. Merge join: sorted tables are merged


select department_name, d.location_id, l.location_id, l.street_address
from hr.departments d, hr.locations l
where d.location_id = l.location_id and department_name like 'S%';

select /*+ USE_HASH(D L) */ department_name, d.location_id, l.location_id, l.street_address
from hr.departments d, hr.locations l
where d.location_id = l.location_id and department_name like 'S%';

select /*+ USE_MERGE(D L) */ department_name, d.location_id, l.location_id, l.street_address
from hr.departments d, hr.locations l
where d.location_id = l.location_id and department_name like 'S%';

select /*+ USE_NL(D L) */ department_name, d.location_id, l.location_id, l.street_address
from hr.departments d, hr.locations l
where d.location_id = l.location_id and department_name like 'S%';


select cust_state_province, sum(s.amount_sold) 
  from sales s, customers c
 where s.cust_id = c.cust_id 
   and c.cust_year_of_birth= 1988 
 group by cust_state_province;

select /*+ USE_NL(s c) */ cust_state_province, sum(s.amount_sold) 
  from sales s, customers c
 where s.cust_id = c.cust_id 
   and c.cust_year_of_birth= 1988 
 group by cust_state_province;

select /*+ NO_QUERY_TRANSFORMATION USE_NL(s c) */ cust_state_province, sum(s.amount_sold) 
  from sales s, customers c
 where s.cust_id = c.cust_id 
   and c.cust_year_of_birth= 1988 
 group by cust_state_province;
 
 select /*+ NO_QUERY_TRANSFORMATION USE_MERGE(s c) */ cust_state_province, sum(s.amount_sold) 
  from sales s, customers c
 where s.cust_id = c.cust_id 
   and c.cust_year_of_birth= 1988 
 group by cust_state_province;
 
 -- Change JOIN Order
 
 -- 1- Change to query join order:
 
 select /*+ NO_QUERY_TRANSFORMATION ORDERED USE_HASH(s c) */ cust_state_province, sum(s.amount_sold) 
  from sales s, customers c
 where s.cust_id = c.cust_id 
   and c.cust_year_of_birth= 1988 
 group by cust_state_province;

-- 2- Change to Leading:

 select /*+ NO_QUERY_TRANSFORMATION LEADING(c,s) USE_HASH(s c) */ cust_state_province, sum(s.amount_sold) 
  from sales s, customers c
 where s.cust_id = c.cust_id 
   and c.cust_year_of_birth= 1988 
 group by cust_state_province;
