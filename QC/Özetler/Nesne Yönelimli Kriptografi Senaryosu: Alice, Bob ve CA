{"cells":[{"cell_type":"markdown","source":["Önceki kodumuzdaki if alice_session_key == decrypted_session_key kontrolü, oturum anahtarının başarıyla şifresinin çözülüp çözülmediğini doğrular. Ancak gerçek dünyada, Bob'un genel anahtarının gerçekten Bob'a ait olduğuna dair güveni sağlayan mekanizma bu değildir. Bu güveni sağlayan, sizin de belirttiğiniz gibi, Sertifika Otoriteleri (CA) ve Genel Anahtar Altyapısı (PKI)'dır.\n","\n","Gerçek hayatta süreç şöyledir:\n","\n","Anahtar Üretimi: Bob kendi özel ve genel anahtar çiftini üretir.\n","\n","Sertifika Talebi (CSR): Bob, genel anahtarını ve kimlik bilgilerini içeren bir Sertifika İmzalama İsteği (CSR) oluşturur ve bunu güvenilir bir CA'ya gönderir.\n","\n","Sertifika İmzalama: CA, Bob'un kimliğini doğrular (örneğin, bir alan adının sahibi olduğunu teyit eder) ve ardından Bob'un genel anahtarını ve kimlik bilgilerini içeren bir dijital sertifika oluşturur. Bu sertifikayı kendi özel anahtarıyla imzalar.\n","\n","Sertifika Dağıtımı: Bob, bu imzalı sertifikayı herkese açık hale getirir (örneğin, bir web sunucusunda yayınlar).\n","\n","Sertifika Doğrulama: Alice, Bob ile iletişim kurmak istediğinde, Bob'un genel anahtarını doğrudan almaz, Bob'un dijital sertifikasını alır. Alice'in sistemi (tarayıcısı gibi), bu sertifikanın CA tarafından imzalanıp imzalanmadığını ve CA'nın kendisinin güvenilir olup olmadığını (CA'nın genel anahtarı sistemde önceden yüklüdür) kontrol eder. Eğer sertifika geçerliyse, Alice Bob'un genel anahtarının gerçekten Bob'a ait olduğuna güvenebilir.\n","\n","Oturum Anahtarı Değişimi: Alice, artık güvenilir olduğuna inandığı Bob'un genel anahtarını kullanarak simetrik oturum anahtarını şifreler ve Bob'a gönderir.\n","\n","Şimdi bu süreci Python koduyla modelleyelim. Person sınıfını güncelleyeceğiz ve bir CertificateAuthority sınıfı ekleyeceğiz.\n","\n","\n","Nesne Yönelimli Kriptografi Senaryosu: Alice, Bob ve Sertifika Otoritesi (CA)\n","\n","Bu kod, asimetrik şifreleme (RSA) ve simetrik şifreleme (AES) kullanarak güvenli iletişimi, Person ve CertificateAuthority sınıfları aracılığıyla modellemektedir. CertificateAuthority bir dijital sertifika yayınlayacak ve Person nesneleri bu sertifikaları kullanarak güvenli iletişim kuracak.\n","\n","Yeni Eklenenler ve Değişiklikler:\n","CertificateAuthority Sınıfı:\n","\n","Kendi RSA anahtar çiftine sahiptir.\n","\n","issue_certificate(person_public_key, person_name): Bir kişinin genel anahtarını ve adını alarak basit bir \"sertifika\" (bu örnekte JSON olarak temsil edilen bir veri yapısı) oluşturur ve bu sertifikayı kendi özel anahtarıyla imzalar. İmza için yine SHA256 özetleme ve RSA imzalama kullanılır.\n","\n","verify_certificate(certificate): Bir sertifikayı alır, içeriğinin özetini hesaplar ve CA'nın kendi genel anahtarını kullanarak sertifikanın imzasını doğrular. Eğer imza geçerliyse, sertifikadan kişinin genel anahtarını çıkarır ve döndürür. Bu, güvenin tesis edildiği yerdir.\n","\n","Person Sınıfındaki Değişiklikler:\n","\n","_certificate özelliği eklendi: Kişinin CA'dan aldığı dijital sertifikayı saklamak için.\n","\n","request_certificate(self, ca) metodu: Bir CertificateAuthority nesnesini argüman olarak alır ve ondan bir sertifika talep eder.\n","\n","encrypt_with_public_key_from_cert(self, data, recipient_certificate, ca) metodu: Bu, önceki encrypt_with_public_key metodunun yerini alır. Artık doğrudan bir genel anahtar yerine alıcının sertifikasını ve CA nesnesini alır.\n","\n","Bu metodun içinde, önce ca.verify_certificate(recipient_certificate) çağrısı yapılır. Bu, Bob'un genel anahtarının gerçekten Bob'a ait olduğuna dair güveni CA aracılığıyla sağlar.\n","\n","Eğer sertifika doğrulanamazsa, şifreleme işlemi iptal edilir.\n","\n","Sertifika geçerliyse, içindeki Bob'un genel anahtarı çıkarılır ve oturum anahtarı bu doğrulanmış genel anahtarla şifrelenir.\n","\n","Senaryo Akışındaki Değişiklikler:\n","CA Oluşturma: Senaryonun başında bir CertificateAuthority nesnesi oluşturulur.\n","\n","Sertifika Talebi: Alice ve Bob, ca.issue_certificate metodunu kullanarak CA'dan kendi sertifikalarını alırlar.\n","\n","Anahtar Değişimi (Sertifika Doğrulaması ile):\n","\n","Alice, simetrik oturum anahtarını oluşturur.\n","\n","Alice, bu oturum anahtarını Bob'a göndermek için alice.encrypt_with_public_key_from_cert metodunu kullanır. Bu metod içinde, Bob'un sertifikası CA tarafından doğrulanır. Bu doğrulama başarılı olursa, Alice Bob'un genel anahtarını güvenle kullanabilir.\n","\n","Eğer sertifika doğrulama başarısız olursa, Alice oturum anahtarını şifrelemeyi reddeder.\n","\n","Geri kalan şifreleme ve şifre çözme adımları, oturum anahtarının güvenli bir şekilde değiş tokuş edildiği varsayılarak devam eder.\n","\n","Bu kod, gerçek dünyadaki PKI'nın temel prensiplerini ve CA'ların bir genel anahtara duyulan güveni nasıl tesis ettiğini daha iyi modellemektedir. if alice_session_key == decrypted_session_key kontrolü hala yerinde olsa da, artık bu sadece şifre çözme işleminin matematiksel olarak doğru yapılıp yapılmadığını kontrol eden son bir adımdır; anahtarın güvenilirliğini sağlayan asıl mekanizma sertifika doğrulamasıdır."],"metadata":{"id":"sV2FKTaaTf8d"}},{"cell_type":"code","source":["from cryptography.hazmat.primitives import serialization, hashes\n","from cryptography.hazmat.primitives.asymmetric import rsa, padding\n","from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\n","from cryptography.hazmat.backends import default_backend\n","from cryptography.hazmat.primitives import padding as sym_padding\n","import os\n","import json # Sertifika verisini JSON olarak saklamak için\n","\n","class CertificateAuthority:\n","    \"\"\"\n","    Sertifika Yetkilisi (CA) sınıfı.\n","    Kendi anahtar çiftine sahiptir ve sertifikaları imzalayıp doğrulayabilir.\n","    \"\"\"\n","    def __init__(self, name=\"MyRootCA\"):\n","        self.name = name\n","        self._private_key = None\n","        self._public_key = None\n","        self._generate_rsa_key_pair()\n","        print(f\"CA: '{self.name}' Sertifika Otoritesi oluşturuldu ve anahtar çifti üretildi.\")\n","\n","    def _generate_rsa_key_pair(self):\n","        \"\"\"CA'nın RSA anahtar çiftini oluşturur.\"\"\"\n","        self._private_key = rsa.generate_private_key(\n","            public_exponent=65537,\n","            key_size=2048,\n","            backend=default_backend()\n","        )\n","        self._public_key = self._private_key.public_key()\n","\n","    @property\n","    def public_key(self):\n","        \"\"\"CA'nın genel anahtarını dışarıdan erişilebilir kılar.\"\"\"\n","        return self._public_key\n","\n","    def issue_certificate(self, person_public_key, person_name):\n","        \"\"\"\n","        Bir kişi için dijital sertifika yayınlar.\n","        Sertifika, kişinin genel anahtarını ve kimliğini içerir ve CA tarafından imzalanır.\n","        \"\"\"\n","        # Sertifika içeriği (gerçek bir sertifika çok daha fazla bilgi içerir)\n","        cert_data = {\n","            \"subject\": person_name,\n","            \"public_key_pem\": person_public_key.public_bytes(\n","                encoding=serialization.Encoding.PEM,\n","                format=serialization.PublicFormat.SubjectPublicKeyInfo\n","            ).decode('utf-8'),\n","            \"issuer\": self.name,\n","            \"valid_from\": \"2023-01-01\", # Basitlik adına sabit tarihler\n","            \"valid_to\": \"2024-12-31\",\n","            \"serial_number\": os.urandom(8).hex() # Basit bir seri numarası\n","        }\n","        cert_data_bytes = json.dumps(cert_data, sort_keys=True).encode('utf-8')\n","\n","        # Sertifika içeriğinin özeti (hash) alınır\n","        digest = hashes.Hash(hashes.SHA256(), backend=default_backend())\n","        digest.update(cert_data_bytes)\n","        hashed_data = digest.finalize()\n","\n","        # Özeti CA'nın özel anahtarıyla imzala\n","        signature = self._private_key.sign(\n","            hashed_data,\n","            padding.PSS(\n","                mgf=padding.MGF1(hashes.SHA256()),\n","                salt_length=padding.PSS.MAX_LENGTH\n","            ),\n","            hashes.SHA256()\n","        )\n","        print(f\"CA: '{person_name}' için sertifika yayınlandı ve imzalandı.\")\n","        return {\"data\": cert_data_bytes, \"signature\": signature}\n","\n","    def verify_certificate(self, certificate):\n","        \"\"\"\n","        Bir sertifikanın CA tarafından imzalanıp imzalanmadığını ve içeriğinin\n","        değiştirilip değiştirilmediğini doğrular.\n","        \"\"\"\n","        cert_data_bytes = certificate[\"data\"]\n","        signature = certificate[\"signature\"]\n","\n","        # Sertifika içeriğinin özeti (hash) alınır\n","        digest = hashes.Hash(hashes.SHA256(), backend=default_backend())\n","        digest.update(cert_data_bytes)\n","        hashed_data = digest.finalize()\n","\n","        try:\n","            # CA'nın genel anahtarını kullanarak imzayı doğrula\n","            self._public_key.verify(\n","                signature,\n","                hashed_data,\n","                padding.PSS(\n","                    mgf=padding.MGF1(hashes.SHA256()),\n","                    salt_length=padding.PSS.MAX_LENGTH\n","                ),\n","                hashes.SHA256()\n","            )\n","            # İmza geçerliyse, sertifika verisini çöz ve kişinin genel anahtarını döndür\n","            cert_content = json.loads(cert_data_bytes.decode('utf-8'))\n","            person_public_key_pem = cert_content[\"public_key_pem\"].encode('utf-8')\n","            person_public_key = serialization.load_pem_public_key(\n","                person_public_key_pem,\n","                backend=default_backend()\n","            )\n","            print(f\"CA: Sertifika '{cert_content['subject']}' için başarıyla doğrulandı.\")\n","            return person_public_key\n","        except Exception as e:\n","            print(f\"CA: Sertifika doğrulama BAŞARISIZ! Hata: {e}\")\n","            return None\n","\n","\n","class Person:\n","    \"\"\"\n","    Kriptografik yeteneklere sahip bir kişiyi temsil eden temel sınıf.\n","    Kendi RSA anahtar çiftine sahiptir ve mesajları şifreleme/şifre çözme\n","    ve oturum anahtarlarını değiş tokuş etme yeteneğine sahiptir.\n","    Ayrıca bir CA'dan sertifika alabilir ve sertifikaları doğrulayabilir.\n","    \"\"\"\n","    def __init__(self, name):\n","        self.name = name\n","        self._private_key = None # Private RSA key\n","        self._public_key = None # Public RSA key\n","        self._certificate = None # Digital certificate issued by a CA\n","        self._session_key = None # Shared symmetric session key\n","        self._generate_rsa_key_pair()\n","        print(f\"{self.name}: '{self.name}' kişisi oluşturuldu ve RSA anahtar çifti üretildi.\")\n","\n","    def _generate_rsa_key_pair(self):\n","        \"\"\"Generates the RSA key pair (private and public).\"\"\"\n","        self._private_key = rsa.generate_private_key(\n","            public_exponent=65537,\n","            key_size=2048,\n","            backend=default_backend()\n","        )\n","        self._public_key = self._private_key.public_key()\n","\n","    @property\n","    def public_key(self):\n","        \"\"\"Makes the public key accessible from outside.\"\"\"\n","        return self._public_key\n","\n","    @property\n","    def certificate(self):\n","        \"\"\"Returns the person's digital certificate.\"\"\"\n","        return self._certificate\n","\n","    def request_certificate(self, ca):\n","        \"\"\"\n","        Requests a digital certificate from a Certificate Authority.\n","        \"\"\"\n","        print(f\"{self.name}: '{ca.name}' CA'dan sertifika talep ediyor...\")\n","        self._certificate = ca.issue_certificate(self.public_key, self.name)\n","        if self._certificate:\n","            print(f\"{self.name}: Sertifikam '{ca.name}' tarafından başarıyla alındı.\")\n","        else:\n","            print(f\"{self.name}: Sertifika alma başarısız oldu.\")\n","\n","    def set_session_key(self, key):\n","        \"\"\"Sets the shared symmetric session key.\"\"\"\n","        self._session_key = key\n","        print(f\"{self.name}: Oturum anahtarı başarıyla ayarlandı.\")\n","\n","    def encrypt_with_public_key_from_cert(self, data, recipient_certificate, ca):\n","        \"\"\"\n","        Veriyi alıcının sertifikasından çıkarılan genel anahtar ile şifreler.\n","        Önce alıcının sertifikasını CA'nın genel anahtarıyla doğrular.\n","        \"\"\"\n","        print(f\"{self.name}: Alıcının sertifikasını '{ca.name}' CA ile doğruluyor...\")\n","        verified_public_key = ca.verify_certificate(recipient_certificate)\n","\n","        if not verified_public_key:\n","            print(f\"{self.name}: Alıcının sertifikası doğrulanamadı. Şifreleme iptal edildi.\")\n","            return None\n","\n","        if not isinstance(data, bytes):\n","            data = str(data).encode('utf-8')\n","\n","        print(f\"{self.name}: Veri ({data[:20]}...) doğrulanmış genel anahtarla şifreleniyor...\")\n","        encrypted_data = verified_public_key.encrypt(\n","            data,\n","            padding.OAEP(\n","                mgf=padding.MGF1(algorithm=hashes.SHA256()),\n","                algorithm=hashes.SHA256(),\n","                label=None\n","            )\n","        )\n","        return encrypted_data\n","\n","    def decrypt_with_private_key(self, encrypted_data):\n","        \"\"\"\n","        Decrypts encrypted data with its own private key.\n","        \"\"\"\n","        print(f\"{self.name}: Şifrelenmiş veri çözülüyor...\")\n","        decrypted_data = self._private_key.decrypt(\n","            encrypted_data,\n","            padding.OAEP(\n","                mgf=padding.MGF1(algorithm=hashes.SHA256()),\n","                algorithm=hashes.SHA256(),\n","                label=None\n","            )\n","        )\n","        return decrypted_data\n","\n","    def generate_session_key(self):\n","        \"\"\"Generates a new symmetric session key for AES.\"\"\"\n","        self._session_key = os.urandom(32) # 256-bit AES key\n","        print(f\"{self.name}: Yeni simetrik oturum anahtarı oluşturuldu: {self._session_key.hex()[:10]}...\")\n","        return self._session_key\n","\n","    def encrypt_message(self, message):\n","        \"\"\"\n","        Symmetrically encrypts a message using the session key.\n","        \"\"\"\n","        if not self._session_key:\n","            raise ValueError(f\"{self.name}: Oturum anahtarı ayarlanmamış. Mesaj şifrelenemez.\")\n","        if not isinstance(message, bytes):\n","            message = str(message).encode('utf-8')\n","\n","        # IV (Initialization Vector) is required for AES CBC\n","        iv = os.urandom(16)\n","        cipher = Cipher(algorithms.AES(self._session_key), modes.CBC(iv), backend=default_backend())\n","        encryptor = cipher.encryptor()\n","\n","        # Padding the message to block size for CBC mode\n","        padder = sym_padding.PKCS7(algorithms.AES.block_size).padder()\n","        padded_data = padder.update(message) + padder.finalize()\n","\n","        encrypted_message = encryptor.update(padded_data) + encryptor.finalize()\n","        print(f\"{self.name}: Mesaj şifrelendi.\")\n","        return iv, encrypted_message # IV must also be sent to the recipient\n","\n","    def decrypt_message(self, iv, encrypted_message):\n","        \"\"\"\n","        Symmetrically decrypts a message using the session key.\n","        \"\"\"\n","        if not self._session_key:\n","            raise ValueError(f\"{self.name}: Oturum anahtarı ayarlanmamış. Mesaj çözülemez.\")\n","\n","        cipher = Cipher(algorithms.AES(self._session_key), modes.CBC(iv), backend=default_backend())\n","        decryptor = cipher.decryptor()\n","\n","        decrypted_padded_message = decryptor.update(encrypted_message) + decryptor.finalize()\n","\n","        # Unpadding the decrypted message\n","        unpadder = sym_padding.PKCS7(algorithms.AES.block_size).unpadder()\n","        message = unpadder.update(decrypted_padded_message) + unpadder.finalize()\n","        print(f\"{self.name}: Mesajın şifresi çözüldü.\")\n","        return message\n","\n","# --- Senaryo Akışı: Alice, Bob ve CA'nın Güvenli İletişimi ---\n","print(\"--------------------------------------------------\")\n","print(\"    Alice, Bob ve CA'nın Güvenli İletişim Senaryosu\")\n","print(\"--------------------------------------------------\\n\")\n","\n","# 1. CA, Alice ve Bob oluşturulur.\n","ca = CertificateAuthority(\"GlobalTrustCA\")\n","alice = Person(\"Alice\")\n","bob = Person(\"Bob\")\n","\n","# 2. Alice ve Bob, CA'dan sertifika talep eder.\n","print(\"\\n--- Adım 1: Sertifika Talebi ve Yayınlama ---\")\n","alice.request_certificate(ca)\n","bob.request_certificate(ca)\n","\n","# 3. Anahtar Değişimi: Alice, Bob'a simetrik bir oturum anahtarı gönderir.\n","#    Bu işlemde Bob'un sertifikası CA tarafından doğrulanır.\n","print(\"\\n--- Adım 2: Oturum Anahtarının Güvenli Değişimi (Sertifika Doğrulaması ile) ---\")\n","# Alice kendi oturum anahtarını oluşturur\n","alice_session_key = alice.generate_session_key()\n","\n","# Alice, bu oturum anahtarını Bob'un sertifikasını kullanarak şifreler.\n","# Bu metot içinde Bob'un sertifikası CA tarafından doğrulanır.\n","encrypted_session_key = alice.encrypt_with_public_key_from_cert(alice_session_key, bob.certificate, ca)\n","\n","if encrypted_session_key is None:\n","    print(\"Alice: Oturum anahtarını şifreleyemedi, çünkü Bob'un sertifikası doğrulanamadı.\")\n","else:\n","    print(f\"Alice: Şifrelenmiş oturum anahtarını Bob'a gönderiyor (simülasyon)..\")\n","\n","    # Bob şifrelenmiş oturum anahtarını alır ve kendi özel anahtarıyla çözer\n","    decrypted_session_key = bob.decrypt_with_private_key(encrypted_session_key)\n","\n","    # Bob, çözdüğü oturum anahtarını kendi objesine kaydeder\n","    bob.set_session_key(decrypted_session_key)\n","\n","    # Anahtarların eşleşip eşleşmediğini kontrol et (bu sadece şifre çözme başarısını kontrol eder)\n","    if alice_session_key == decrypted_session_key:\n","        print(\"Anahtar Değişimi Başarılı: Alice ve Bob aynı oturum anahtarına sahip!\")\n","    else:\n","        print(\"Anahtar Değişimi Başarısız!\")\n","\n","# 4. Güvenli Mesajlaşma: Alice, Bob'a şifreli bir mesaj gönderir.\n","#    Bu adım öncekiyle aynı, çünkü oturum anahtarı zaten değiş tokuş edildi.\n","if alice_session_key == decrypted_session_key: # Sadece anahtar değişimi başarılıysa devam et\n","    print(\"\\n--- Adım 3: Simetrik Şifreleme ile Mesajlaşma ---\")\n","\n","    # Alice bir mesaj hazırlar\n","    original_message = \"Merhaba Bob, bu simetrik anahtar ile sifrelenmis ilk gizli mesajim!\"\n","    print(f\"Alice: Gönderilecek orijinal mesaj: '{original_message}'\")\n","\n","    # Alice mesajı kendi oturum anahtarıyla şifreler\n","    iv_from_alice, encrypted_message_from_alice = alice.encrypt_message(original_message)\n","\n","    # Alice, şifrelenmiş mesajı ve IV'yi Bob'a gönderir (simülasyon)\n","    print(f\"Alice: Şifrelenmiş mesajı ve IV'yi Bob'a gönderiyor ({encrypted_message_from_alice.hex()[:50]}...)\")\n","\n","    # Bob şifrelenmiş mesajı ve IV'yi alır\n","    bob_receives_iv = iv_from_alice\n","    bob_receives_encrypted_message = encrypted_message_from_alice\n","\n","    # Bob mesajı kendi oturum anahtarıyla çözer\n","    decrypted_message_by_bob = bob.decrypt_message(bob_receives_iv, bob_receives_encrypted_message)\n","    print(f\"Bob: Şifresi çözülen mesaj: '{decrypted_message_by_bob.decode()}'\")\n","\n","    # Mesajların eşleştiğini doğrula\n","    if original_message.encode('utf-8') == decrypted_message_by_bob:\n","        print(\"Mesajlaşma Başarılı: Orijinal mesaj ve çözülen mesaj eşleşiyor!\")\n","    else:\n","        print(\"Mesajlaşma Başarısız!\")\n","else:\n","    print(\"\\nMesajlaşma yapılamadı çünkü anahtar değişimi başarısız oldu.\")\n","\n","print(\"\\n--------------------------------------------------\")\n","print(\"Senaryo Sonu.\")\n","print(\"--------------------------------------------------\")"],"outputs":[],"execution_count":null,"metadata":{"id":"7illBEqvTfQ9"}}],"metadata":{"colab":{"provenance":[]},"kernelspec":{"display_name":"Python 3","name":"python3"}},"nbformat":4,"nbformat_minor":0}